<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Universal Dodge — Simple Cross-Device HTML5 Game</title>
  <style>
    :root{--bg:#0b1220;--fg:#e6eef6;--accent:#06b6d4}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;color:var(--fg);background:linear-gradient(180deg,#071024 0%,#081428 100%)}
    .wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:12px}
    .card{width:min(900px,100%);max-width:980px;background:rgba(255,255,255,0.03);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{font-size:18px;margin:0}
    #gameCanvas{display:block;width:100%;height:60vh;border-radius:8px;background:#071428}
    .controls{display:flex;gap:8px;margin-top:8px;align-items:center}
    button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#042235;font-weight:700;cursor:pointer}
    .info{color:#94a3b8;font-size:13px;margin-top:8px}
    .footer{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:#94a3b8;font-size:13px}
    @media (max-width:600px){#gameCanvas{height:50vh}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>Universal Dodge — Tap / Space / Click to Jump</h1>
        <div id="scoreTop">Score: 0</div>
      </header>

      <canvas id="gameCanvas" width="900" height="600" aria-label="Dodge the blocks game"></canvas>

      <div class="controls">
        <button id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="restartBtn">Restart</button>
        <div style="flex:1"></div>
        <div style="font-size:13px;color:#94a3b8">Use touch / mouse / space / up arrow. Runs on phones, tablets & desktops.</div>
      </div>

      <div class="info">
        Avoid incoming obstacles. The longer you survive, the higher the score. Difficulty slowly increases.
      </div>

      <div class="footer">
        <div>Made with HTML5 canvas — single file</div>
        <div><small>Tap to jump ▸</small></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas')
  const ctx = canvas.getContext('2d')
  const scoreTop = document.getElementById('scoreTop')
  const startBtn = document.getElementById('startBtn')
  const pauseBtn = document.getElementById('pauseBtn')
  const restartBtn = document.getElementById('restartBtn')

  // make canvas crisp on high DPI
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect()
    const dpr = window.devicePixelRatio || 1
    canvas.width = Math.round(rect.width * dpr)
    canvas.height = Math.round(rect.height * dpr)
    ctx.setTransform(dpr,0,0,dpr,0,0)
  }
  window.addEventListener('resize', resizeCanvas)
  resizeCanvas()

  // Game state
  let running = false
  let paused = false
  let lastTime = 0
  let spawnTimer = 0
  let spawnInterval = 1500 // ms
  let difficultyTimer = 0
  let score = 0

  // Player
  const player = {
    x: 80,
    y: 0,
    r: 18,
    vy: 0,
    gravity: 1100, // px/s^2
    jumpSpeed: -420,
    grounded: false
  }

  // Ground line (virtual)
  function groundY(){
    return canvas.height / (window.devicePixelRatio||1) - 48
  }

  // Obstacles
  const obstacles = []

  function spawnObstacle(){
    const h = 20 + Math.random()*70
    const w = 18 + Math.random()*70
    const y = groundY() - h
    obstacles.push({x: canvas.width/(window.devicePixelRatio||1) + 20, y, w, h, passed:false})
  }

  function resetGame(){
    obstacles.length = 0
    score = 0
    spawnInterval = 1500
    difficultyTimer = 0
    spawnTimer = 0
    player.y = groundY() - player.r
    player.vy = 0
    player.grounded = true
    updateScoreUI()
  }

  function startGame(){
    running = true
    paused = false
    lastTime = performance.now()
    resetGame()
    loop(lastTime)
  }

  function pauseGame(){
    paused = !paused
    pauseBtn.textContent = paused ? 'Resume' : 'Pause'
  }

  function restartGame(){
    resetGame()
    if(!running){ startGame() }
  }

  function updateScoreUI(){
    scoreTop.textContent = 'Score: ' + Math.floor(score)
  }

  function gameOver(){
    running = false
    // show simple overlay text
    ctx.save()
    ctx.fillStyle = 'rgba(2,6,23,0.6)'
    ctx.fillRect(0,0,canvas.width/(window.devicePixelRatio||1),canvas.height/(window.devicePixelRatio||1))
    ctx.fillStyle = '#fff'
    ctx.font = '24px system-ui, Arial'
    ctx.textAlign = 'center'
    ctx.fillText('Game Over — Score: ' + Math.floor(score), canvas.width/(2*(window.devicePixelRatio||1)), canvas.height/(2*(window.devicePixelRatio||1)) - 10)
    ctx.font = '14px system-ui, Arial'
    ctx.fillText('Click Start or press Space to play again', canvas.width/(2*(window.devicePixelRatio||1)), canvas.height/(2*(window.devicePixelRatio||1)) + 20)
    ctx.restore()
  }

  function loop(t){
    if(!running) return
    if(paused){ lastTime = t; requestAnimationFrame(loop); return }
    const dt = Math.min(50, t - lastTime) / 1000 // in seconds, clamp for big frames
    lastTime = t

    // update
    spawnTimer += dt*1000
    difficultyTimer += dt*1000
    if(spawnTimer > spawnInterval){ spawnTimer = 0; spawnObstacle() }

    // increase difficulty slowly
    if(difficultyTimer > 4000){ difficultyTimer = 0; spawnInterval = Math.max(500, spawnInterval - 40) }

    // update player physics
    player.vy += player.gravity * dt
    player.y += player.vy * dt
    const gY = groundY() - player.r
    if(player.y >= gY){ player.y = gY; player.vy = 0; player.grounded = true } else player.grounded = false

    // move obstacles
    const speed = 200 + (Math.min(1200, score)*0.6) // speed increases with score
    for(let i = obstacles.length-1; i >=0; i--){
      const ob = obstacles[i]
      ob.x -= speed * dt
      // collision check: circle vs rect
      const cx = Math.max(ob.x, Math.min(player.x, ob.x + ob.w))
      const cy = Math.max(ob.y, Math.min(player.y, ob.y + ob.h))
      const dx = cx - player.x
      const dy = cy - player.y
      if((dx*dx + dy*dy) < player.r*player.r){ // hit
        gameOver(); return
      }
      if(!ob.passed && (ob.x + ob.w) < player.x){ ob.passed = true; score += 10 }
      if(ob.x + ob.w < -50) obstacles.splice(i,1)
    }

    // score by time
    score += dt * 5
    updateScoreUI()

    // draw
    render()

    // next frame
    requestAnimationFrame(loop)
  }

  function render(){
    const w = canvas.width/(window.devicePixelRatio||1)
    const h = canvas.height/(window.devicePixelRatio||1)
    ctx.clearRect(0,0,w,h)

    // sky / gradient
    const g = ctx.createLinearGradient(0,0,0,h)
    g.addColorStop(0,'#071428')
    g.addColorStop(1,'#021122')
    ctx.fillStyle = g
    ctx.fillRect(0,0,w,h)

    // ground
    ctx.fillStyle = '#0f1724'
    ctx.fillRect(0, groundY(), w, h - groundY())

    // player
    ctx.beginPath()
    ctx.fillStyle = '#06b6d4'
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2)
    ctx.fill()

    // obstacles
    obstacles.forEach(ob => {
      ctx.fillStyle = '#ef4444'
      ctx.fillRect(ob.x, ob.y, ob.w, ob.h)
    })

    // HUD small
    ctx.fillStyle = 'rgba(255,255,255,0.06)'
    ctx.fillRect(12,12,120,34)
    ctx.fillStyle = '#dff6f9'
    ctx.font = '14px system-ui, Arial'
    ctx.textAlign = 'left'
    ctx.fillText('Score: ' + Math.floor(score), 20, 34)
  }

  // controls
  function jump(){
    if(!running){ startGame(); return }
    if(paused) return
    // small jump if in air reduces
    player.vy = player.jumpSpeed
    player.grounded = false
  }

  // pointer / touch
  canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); jump() })
  // keyboard
  window.addEventListener('keydown', (e) => {
    if(e.code === 'Space' || e.code === 'ArrowUp'){
      e.preventDefault(); jump()
    }
    if(e.code === 'KeyP'){ pauseGame() }
  })

  // buttons
  startBtn.addEventListener('click', () => { startGame() })
  pauseBtn.addEventListener('click', () => { pauseGame() })
  restartBtn.addEventListener('click', () => { restartGame() })

  // initial
  resetGame()
  render()

  // friendly autoplay hint for mobile: enable start on first touch
  canvas.addEventListener('touchstart', function once(){ canvas.removeEventListener('touchstart', once) })

  // Ensure game resumes correctly if the tab becomes visible again
  document.addEventListener('visibilitychange', () => { if(document.hidden) paused = true; else paused = false; pauseBtn.textContent = paused ? 'Resume' : 'Pause' })

})();
</script>
</body>
</html>
